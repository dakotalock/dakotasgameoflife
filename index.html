
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cellular Cosmos Sandbox</title>
    <!-- Tailwind CSS CDN for rapid styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for main layout and canvas to ensure responsiveness and proper display */
        html, body, #app {
            height: 100%;
            margin: 0;
            overflow: hidden; /* Prevents scrollbars on the main layout */
        }
        #app {
            display: grid;
            grid-template-rows: 1fr auto; /* Main content area (canvas + sidebars) and then status bar */
            grid-template-columns: 280px 1fr 280px; /* Left sidebar, central canvas, right sidebar */
            gap: 1rem; /* Spacing between grid items */
            padding: 1rem;
            background-color: #1a202c; /* Dark background for the whole app */
            color: #e2e8f0; /* Light text color */
        }

        /* Responsive adjustments for smaller screens (tablets and mobile) */
        @media (max-width: 1024px) {
            #app {
                /* Stack elements vertically: Controls, Rules, Canvas, Status */
                grid-template-rows: auto auto 1fr auto;
                grid-template-columns: 1fr; /* Single column layout */
                padding: 0.5rem;
                gap: 0.5rem;
            }
            /* Make sidebars scrollable if content overflows */
            #control-panel, #rule-editor-panel {
                max-height: 40vh; /* Limit height to prevent excessive scrolling */
                overflow-y: auto;
            }
            #main-canvas-area {
                min-height: 300px; /* Ensure canvas area has a minimum visible height */
            }
        }
        /* Desktop layout (default grid definitions) */
        @media (min-width: 1024px) {
            #control-panel {
                grid-column: 1;
                grid-row: 1;
            }
            #main-canvas-area {
                grid-column: 2;
                grid-row: 1;
            }
            #rule-editor-panel {
                grid-column: 3;
                grid-row: 1;
            }
            #status-bar {
                grid-column: 1 / span 3; /* Span all three columns at the bottom */
                grid-row: 2;
            }
        }

        /* Common styles for panels using Tailwind's @apply directive */
        .panel {
            @apply bg-gray-800 p-4 rounded-lg shadow-lg flex flex-col gap-4;
        }
        .section-title {
            @apply text-lg font-semibold text-blue-400 mb-2;
        }
        .btn {
            @apply bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200;
        }
        .btn-secondary {
            @apply bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200;
        }
        .input-field {
            @apply w-full p-2 rounded-md bg-gray-700 text-gray-200 border border-gray-600 focus:border-blue-500 focus:ring focus:ring-blue-500 focus:ring-opacity-50;
        }
        .slider-label {
            @apply block text-sm font-medium text-gray-300 mb-1;
        }
        .checkbox-label {
            @apply flex items-center cursor-pointer;
        }
        .checkbox-label input[type="checkbox"], .form-radio {
            @apply h-4 w-4 text-blue-600 bg-gray-700 rounded border-gray-600 focus:ring-blue-500;
        }
        .form-radio {
            @apply rounded-full; /* Make radio buttons round */
        }
        .color-picker-label {
            @apply flex items-center justify-between text-sm font-medium text-gray-300;
        }
        .color-picker-input {
            @apply w-12 h-8 rounded-md border border-gray-600 cursor-pointer;
        }
        /* Canvas specific styles */
        canvas {
            display: block; /* Removes extra space below canvas */
            background-color: #000; /* Default background for dead cells / empty grid */
            max-width: 100%; /* Ensures canvas scales down to fit parent horizontally */
            max-height: 100%; /* Ensures canvas scales down to fit parent vertically */
            image-rendering: pixelated; /* For sharp pixel rendering when zoomed */
            image-rendering: crisp-edges; /* Alternative for pixelated rendering */
        }
    </style>
</head>
<body class="font-sans antialiased">
    <div id="app" class="min-h-screen">
        <!-- Left Sidebar: Control Panel -->
        <aside id="control-panel" class="panel">
            <h2 class="section-title">Simulation Controls</h2>
            <div class="flex gap-2">
                <button id="playPauseBtn" class="btn flex-1" aria-label="Play or Pause Simulation">Play</button>
                <button id="stepBtn" class="btn-secondary" aria-label="Step one generation forward">Step</button>
                <button id="resetBtn" class="btn-secondary" aria-label="Reset simulation grid">Reset</button>
            </div>
            <div>
                <label for="speedSlider" class="slider-label">Speed: <span id="speedValue">10x</span></label>
                <input type="range" id="speedSlider" min="1" max="60" value="10" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer" aria-valuetext="10 generations per second">
            </div>

            <h2 class="section-title">Drawing Tools</h2>
            <div>
                <label for="brushSizeSlider" class="slider-label">Brush Size: <span id="brushSizeValue">1</span></label>
                <input type="range" id="brushSizeSlider" min="1" max="5" value="1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer" aria-valuetext="1 pixel brush size">
            </div>
            <div class="flex gap-2">
                <button id="fillGridBtn" class="btn-secondary flex-1" aria-label="Fill entire grid with live cells">Fill Grid</button>
                <button id="clearGridBtn" class="btn-secondary flex-1" aria-label="Clear all cells from grid">Clear Grid</button>
            </div>

            <h2 class="section-title">Pattern Presets</h2>
            <select id="presetSelect" class="input-field" aria-label="Select a predefined pattern to load">
                <option value="">Select a preset...</option>
                <option value="glider">Glider (Conway)</option>
                <option value="lightWeightSpaceship">Light-weight Spaceship (Conway)</option>
                <option value="gosperGliderGun">Gosper Glider Gun (Conway)</option>
                <option value="pulsar">Pulsar (Conway)</option>
                <option value="tenCellRow">10 Cell Row (Conway)</option>
            </select>
            <div class="flex gap-2">
                <button id="savePatternBtn" class="btn-secondary flex-1" aria-label="Save current pattern to local storage">Save Pattern</button>
                <button id="loadPatternBtn" class="btn-secondary flex-1" aria-label="Load a pattern from local storage">Load Pattern</button>
            </div>
        </aside>

        <!-- Main Canvas Area -->
        <main id="main-canvas-area" class="bg-gray-800 rounded-lg shadow-lg flex items-center justify-center relative overflow-hidden">
            <canvas id="cellularCanvas" role="img" aria-label="Cellular Automata Grid"></canvas>
        </main>

        <!-- Right Sidebar: Rule Editor & Visual Settings -->
        <aside id="rule-editor-panel" class="panel">
            <h2 class="section-title">Cellular Automata Rules</h2>
            <div>
                <label for="ruleInput" class="slider-label">Rule (B/S notation):</label>
                <input type="text" id="ruleInput" value="B13/S23" class="input-field" aria-label="Cellular automata rule in B slash S notation, e.g., B3/S23 for Game of Life">
                <p class="text-xs text-gray-400 mt-1">Example: B13/S23 (Dakota's Game of Life)</p>
            </div>

            <h3 class="font-semibold text-gray-300 mt-2">Neighborhood Type:</h3>
            <div class="flex gap-4 mt-1">
                <label class="checkbox-label">
                    <input type="radio" name="neighborhoodType" value="moore" checked class="form-radio" aria-label="Moore neighborhood type (8 surrounding cells)">
                    <span class="ml-2">Moore (8 neighbors)</span>
                </label>
                <label class="checkbox-label">
                    <input type="radio" name="neighborhoodType" value="vonNeumann" class="form-radio" aria-label="Von Neumann neighborhood type (4 adjacent cells)">
                    <span class="ml-2">Von Neumann (4 neighbors)</span>
                </label>
            </div>

            <h3 class="font-semibold text-gray-300 mt-2">Visual Rule Builder:</h3>
            <div class="grid grid-cols-3 gap-2 text-sm">
                <div class="font-semibold text-blue-300 col-span-3">Birth Conditions (number of live neighbors for a dead cell to become alive):</div>
                <div id="birthConditions" class="col-span-3 grid grid-cols-5 gap-2" role="group" aria-labelledby="birth-conditions-title">
                    <!-- Checkboxes for 0-8 will be generated here by JavaScript -->
                </div>
                <div class="font-semibold text-blue-300 col-span-3 mt-2">Survival Conditions (number of live neighbors for a live cell to remain alive):</div>
                <div id="survivalConditions" class="col-span-3 grid grid-cols-5 gap-2" role="group" aria-labelledby="survival-conditions-title">
                    <!-- Checkboxes for 0-8 will be generated here by JavaScript -->
                </div>
            </div>

            <h2 class="section-title mt-4">Visual Settings</h2>
            <div>
                <label class="color-picker-label">
                    Alive Cell Color:
                    <input type="color" id="aliveColorPicker" value="#00FF00" class="color-picker-input" aria-label="Color for alive cells">
                </label>
            </div>
            <div>
                <label class="color-picker-label">
                    Dead Cell Color:
                    <input type="color" id="deadColorPicker" value="#000000" class="color-picker-input" aria-label="Color for dead cells">
                </label>
            </div>
            <div>
                <label class="checkbox-label">
                    <input type="checkbox" id="gridLinesToggle" checked class="form-checkbox" aria-label="Toggle grid lines visibility">
                    <span class="ml-2">Show Grid Lines</span>
                </label>
            </div>
            <div>
                <label for="zoomSlider" class="slider-label">Zoom: <span id="zoomValue">1.0x</span></label>
                <input type="range" id="zoomSlider" min="0.5" max="5" step="0.1" value="1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer" aria-valuetext="1 times zoom">
            </div>
            <button id="shareLinkBtn" class="btn-secondary" aria-label="Generate shareable link for current state">Share Current State</button>
        </aside>

        <!-- Bottom: Status Bar -->
        <footer id="status-bar" class="bg-gray-800 p-3 rounded-lg shadow-lg flex justify-around items-center text-sm font-semibold">
            <span>Generation: <span id="generationCount">0</span></span>
            <span>Live Cells: <span id="liveCellCount">0</span></span>
            <span>FPS: <span id="fpsCount">0</span></span>
        </footer>
    </div>

    <!-- Modals for saved patterns -->
    <div id="loadPatternModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 hidden" role="dialog" aria-modal="true" aria-labelledby="loadPatternModalTitle">
        <div class="bg-gray-800 p-6 rounded-lg shadow-xl w-96">
            <h3 id="loadPatternModalTitle" class="text-xl font-semibold mb-4">Load Saved Pattern</h3>
            <div id="modalSavedPatternsList" class="max-h-60 overflow-y-auto mb-4 bg-gray-700 p-2 rounded">
                <p class="text-gray-400">No saved patterns found.</p>
            </div>
            <div class="flex justify-end gap-2">
                <button id="closeModalBtn" class="btn-secondary" aria-label="Close load pattern dialog">Close</button>
            </div>
        </div>
    </div>


    <script>
        // Encapsulate all application logic within an immediately invoked function expression (IIFE)
        // to prevent global scope pollution.
        (function() {
            // --- Configuration Constants ---
            const GRID_WIDTH = 100; // Fixed width of the cellular automaton grid
            const GRID_HEIGHT = 100; // Fixed height of the cellular automaton grid
            const BASE_CELL_SIZE_PX = 8; // Base pixel size for a cell before any zoom is applied
            const LOCAL_STORAGE_KEY = 'cellularCosmosPatterns'; // Key for storing user patterns in local storage

            // --- DOM Element References ---
            // Cache references to frequently used DOM elements for performance
            const canvas = document.getElementById('cellularCanvas');
            const ctx = canvas.getContext('2d'); // Get 2D rendering context for the canvas
            const playPauseBtn = document.getElementById('playPauseBtn');
            const stepBtn = document.getElementById('stepBtn');
            const resetBtn = document.getElementById('resetBtn');
            const speedSlider = document.getElementById('speedSlider');
            const speedValueSpan = document.getElementById('speedValue');
            const brushSizeSlider = document.getElementById('brushSizeSlider');
            const brushSizeValueSpan = document.getElementById('brushSizeValue');
            const fillGridBtn = document.getElementById('fillGridBtn');
            const clearGridBtn = document.getElementById('clearGridBtn');
            const presetSelect = document.getElementById('presetSelect');
            const savePatternBtn = document.getElementById('savePatternBtn');
            const loadPatternBtn = document.getElementById('loadPatternBtn');
            const ruleInput = document.getElementById('ruleInput');
            const neighborhoodTypeRadios = document.querySelectorAll('input[name="neighborhoodType"]');
            const birthConditionsDiv = document.getElementById('birthConditions');
            const survivalConditionsDiv = document.getElementById('survivalConditions');
            const aliveColorPicker = document.getElementById('aliveColorPicker');
            const deadColorPicker = document.getElementById('deadColorPicker');
            const gridLinesToggle = document.getElementById('gridLinesToggle');
            const zoomSlider = document.getElementById('zoomSlider');
            const zoomValueSpan = document.getElementById('zoomValue');
            const generationCountSpan = document.getElementById('generationCount');
            const liveCellCountSpan = document.getElementById('liveCellCount');
            const fpsCountSpan = document.getElementById('fpsCount');
            const loadPatternModal = document.getElementById('loadPatternModal');
            const modalSavedPatternsList = document.getElementById('modalSavedPatternsList');
            const closeModalBtn = document.getElementById('closeModalBtn');
            const shareLinkBtn = document.getElementById('shareLinkBtn');

            // --- Application State ---
            // Centralized state object to manage all dynamic data of the application.
            // Using a plain object with a `setState` helper for simplicity in a single-file app,
            // mimicking a lightweight state management pattern.
            let state = {
                gridWidth: GRID_WIDTH,
                gridHeight: GRID_HEIGHT,
                currentGrid: new Uint8Array(GRID_WIDTH * GRID_HEIGHT), // Stores cell states (0 or 1)
                nextGrid: new Uint8Array(GRID_WIDTH * GRID_HEIGHT), // Buffer for next generation computation
                simulationRunning: false,
                animationFrameId: null, // ID returned by requestAnimationFrame
                generation: 0,
                liveCells: 0,
                simulationSpeed: 10, // Target generations per second
                framesToSkip: 0, // Number of animation frames to skip before computing next generation
                frameCounter: 0, // Counter for skipped frames
                lastFrameTime: 0, // Timestamp of the last frame for FPS calculation
                fps: 0,
                brushSize: 1, // Size of the drawing brush (1x1, 3x3, etc.)
                isDrawing: false, // Flag for canvas drawing interaction
                drawMode: 1, // 1 for drawing alive cells, 0 for erasing (drawing dead cells)
                rules: {
                    birth: new Set([3]), // Set of neighbor counts for a dead cell to become alive
                    survival: new Set([2, 3]), // Set of neighbor counts for an alive cell to remain alive
                    neighborhood: 'moore' // 'moore' (8 neighbors) or 'vonNeumann' (4 neighbors)
                },
                cellColors: {
                    alive: '#00FF00', // Default color for alive cells (green)
                    dead: '#000000' // Default color for dead cells (black)
                },
                gridLinesVisible: true, // Toggle visibility of grid lines
                zoomLevel: 1.0, // Current zoom level for the canvas
                savedPatterns: {} // Object to store user-saved patterns from local storage
            };

            // --- Web Worker Setup ---
            // The core simulation logic runs in a Web Worker to prevent UI freezing.
            let worker;
            const setupWorker = () => {
                // Inline worker code as a string to embed directly in the HTML file.
                const workerCode = `
                    let gridWidth, gridHeight;
                    let currentGrid;
                    let birthRules, survivalRules;
                    let neighborhoodType;

                    // Helper function to convert 2D coordinates to a 1D array index
                    function getIndex(x, y) {
                        return y * gridWidth + x;
                    }

                    // Counts the number of live neighbors for a given cell (x, y)
                    function getNeighborCount(x, y) {
                        let count = 0;
                        const neighbors = [];

                        if (neighborhoodType === 'moore') {
                            // Moore neighborhood: includes all 8 surrounding cells
                            neighbors.push(
                                [x - 1, y - 1], [x, y - 1], [x + 1, y - 1],
                                [x - 1, y],                 [x + 1, y],
                                [x - 1, y + 1], [x, y + 1], [x + 1, y + 1]
                            );
                        } else {
                            // Von Neumann neighborhood: includes only 4 immediately adjacent cells (cross shape)
                            neighbors.push(
                                [x, y - 1], // Top
                                [x - 1, y], // Left
                                [x + 1, y], // Right
                                [x, y + 1]  // Bottom
                            );
                        }

                        for (const [nx, ny] of neighbors) {
                            // Implement toroidal (wrap-around) boundaries
                            const wrappedX = (nx + gridWidth) % gridWidth;
                            const wrappedY = (ny + gridHeight) % gridHeight;
                            // Correct for negative modulo results in some JS implementations
                            const finalX = wrappedX < 0 ? wrappedX + gridWidth : wrappedX;
                            const finalY = wrappedY < 0 ? wrappedY + gridHeight : wrappedY;

                            if (currentGrid[getIndex(finalX, finalY)] === 1) {
                                count++;
                            }
                        }
                        return count;
                    }

                    // Computes the next state of the grid based on the current state and rules
                    function computeNextGeneration() {
                        const newGrid = new Uint8Array(gridWidth * gridHeight); // Create a new buffer for the next state
                        let liveCellsCount = 0; // Track live cells for status update

                        for (let y = 0; y < gridHeight; y++) {
                            for (let x = 0; x < gridWidth; x++) {
                                const index = getIndex(x, y);
                                const currentState = currentGrid[index];
                                const liveNeighbors = getNeighborCount(x, y);

                                if (currentState === 1) { // If the cell is currently alive
                                    if (survivalRules.has(liveNeighbors)) {
                                        newGrid[index] = 1; // It survives
                                        liveCellsCount++;
                                    } else {
                                        newGrid[index] = 0; // It dies
                                    }
                                } else { // If the cell is currently dead
                                    if (birthRules.has(liveNeighbors)) {
                                        newGrid[index] = 1; // It is born
                                        liveCellsCount++;
                                    } else {
                                        newGrid[index] = 0; // It remains dead
                                    }
                                }
                            }
                        }
                        return { newGrid, liveCellsCount };
                    }

                    // Message handler for the Web Worker
                    self.onmessage = function(event) {
                        const { type, payload } = event.data;

                        if (type === 'init') {
                            // Initialize worker with grid dimensions
                            gridWidth = payload.gridWidth;
                            gridHeight = payload.gridHeight;
                        } else if (type === 'compute') {
                            // Receive current grid and rules from the main thread
                            currentGrid = payload.currentGrid;
                            birthRules = new Set(payload.birthRules); // Convert array back to Set
                            survivalRules = new Set(payload.survivalRules);
                            neighborhoodType = payload.neighborhoodType;

                            // Compute the next generation
                            const { newGrid, liveCellsCount } = computeNextGeneration();
                            // Send the new grid and live cell count back to the main thread.
                            // Use transferable objects ([newGrid.buffer]) for performance to avoid copying large data.
                            self.postMessage({ type: 'computed', newGrid, liveCellsCount }, [newGrid.buffer]);
                        }
                    };
                `;

                // Create a Blob from the worker code string
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                // Create a URL for the Blob (this allows the browser to run the string as a script)
                const blobURL = URL.createObjectURL(blob);
                worker = new Worker(blobURL);

                // Handle messages coming back from the Web Worker
                worker.onmessage = function(event) {
                    if (event.data.type === 'computed') {
                        // The newGrid buffer has been transferred, so we can directly use it
                        state.currentGrid = event.data.newGrid;
                        state.liveCells = event.data.liveCellsCount;
                        state.generation++;
                        updateStatusBar(); // Update UI metrics
                        drawGrid(); // Render the newly computed grid

                        // If simulation is still running, request the next animation frame
                        if (state.simulationRunning) {
                            state.animationFrameId = requestAnimationFrame(gameLoop);
                        }
                    }
                };

                // Send initial grid dimensions to the worker
                worker.postMessage({ type: 'init', payload: { gridWidth: state.gridWidth, gridHeight: state.gridHeight } });
            };

            // --- State Management Helper ---
            // A simple `setState` function to update the application state and trigger UI updates.
            function setState(newState) {
                // Merge the new state with the existing state
                Object.assign(state, newState);

                // Perform specific UI updates based on which state properties changed
                if ('simulationRunning' in newState) {
                    playPauseBtn.textContent = state.simulationRunning ? 'Pause' : 'Play';
                    playPauseBtn.setAttribute('aria-label', state.simulationRunning ? 'Pause simulation' : 'Play simulation');
                }
                if ('simulationSpeed' in newState) {
                    speedValueSpan.textContent = `${state.simulationSpeed}x`;
                    // Calculate frames to skip for desired generations per second (assuming 60 FPS monitor)
                    state.framesToSkip = Math.max(0, Math.floor(60 / state.simulationSpeed) - 1);
                }
                if ('brushSize' in newState) {
                    brushSizeValueSpan.textContent = state.brushSize;
                }
                if ('zoomLevel' in newState) {
                    zoomValueSpan.textContent = `${state.zoomLevel.toFixed(1)}x`;
                    drawGrid(); // Redraw immediately when zoom changes
                }
                if ('cellColors' in newState || 'gridLinesVisible' in newState) {
                    drawGrid(); // Redraw immediately if visual settings change
                }
                if ('rules' in newState) {
                    updateRuleUIFromState(); // Update rule input and checkboxes
                }
                if ('generation' in newState || 'liveCells' in newState || 'fps' in newState) {
                    updateStatusBar(); // Update status bar metrics
                }
            }

            // --- Grid Operations ---
            // Helper to get the 1D array index from 2D grid coordinates
            function getIndex(x, y) {
                return y * state.gridWidth + x;
            }

            // Initializes the grid, either empty or completely filled with alive cells
            function initializeGrid(fill = false) {
                for (let i = 0; i < state.currentGrid.length; i++) {
                    state.currentGrid[i] = fill ? 1 : 0;
                }
                state.liveCells = fill ? state.currentGrid.length : 0; // Update live cell count
                state.generation = 0; // Reset generation count
                updateStatusBar();
                drawGrid();
            }

            // Sets the state of a single cell at given grid coordinates
            function setCell(x, y, value) {
                // Ensure coordinates are within grid boundaries
                if (x >= 0 && x < state.gridWidth && y >= 0 && y < state.gridHeight) {
                    const index = getIndex(x, y);
                    // Only update if the state actually changes
                    if (state.currentGrid[index] !== value) {
                        state.currentGrid[index] = value;
                        // Live cell count is updated after drawing stops (mouseup) or after a simulation step
                    }
                }
            }

            // Draws cells on the canvas using the current brush size and draw mode
            function drawBrush(canvasX, canvasY, value) {
                // Convert canvas pixel coordinates to grid coordinates, accounting for current zoom
                const gridX = Math.floor(canvasX / (BASE_CELL_SIZE_PX * state.zoomLevel));
                const gridY = Math.floor(canvasY / (BASE_CELL_SIZE_PX * state.zoomLevel));
                const brushRadius = Math.floor((state.brushSize - 1) / 2); // Calculate brush radius from size

                // Iterate over the brush area and set cell states
                for (let y = gridY - brushRadius; y <= gridY + brushRadius; y++) {
                    for (let x = gridX - brushRadius; x <= gridX + brushRadius; x++) {
                        setCell(x, y, value);
                    }
                }
                drawGrid(); // Redraw the canvas immediately after each brush stroke
            }

            // --- Canvas Rendering ---
            // Sets the internal resolution of the canvas element
            function setupCanvasDimensions() {
                canvas.width = state.gridWidth * BASE_CELL_SIZE_PX;
                canvas.height = state.gridHeight * BASE_CELL_SIZE_PX;
                // The CSS `max-width: 100%; max-height: 100%;` will handle scaling the canvas element
                // to fit its parent container, while `ctx.scale` handles the internal zoom.
            }

            // Draws the entire grid onto the canvas
            function drawGrid() {
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the entire canvas

                ctx.save(); // Save the current state of the canvas context (before scaling)
                ctx.scale(state.zoomLevel, state.zoomLevel); // Apply the current zoom transformation

                const aliveColor = state.cellColors.alive;
                const deadColor = state.cellColors.dead;
                const baseCellSize = BASE_CELL_SIZE_PX; // Use base size for drawing operations after scale

                // Iterate through the grid and draw each cell
                for (let y = 0; y < state.gridHeight; y++) {
                    for (let x = 0; x < state.gridWidth; x++) {
                        const index = getIndex(x, y);
                        const cellState = state.currentGrid[index];

                        ctx.fillStyle = cellState === 1 ? aliveColor : deadColor;
                        ctx.fillRect(x * baseCellSize, y * baseCellSize, baseCellSize, baseCellSize);
                    }
                }

                // Draw grid lines if enabled and cells are large enough to make them visible
                if (state.gridLinesVisible && (baseCellSize * state.zoomLevel) > 5) {
                    ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)'; // Semi-transparent gray lines
                    ctx.lineWidth = 0.5 / state.zoomLevel; // Adjust line width to appear consistent regardless of zoom

                    // Draw vertical lines
                    for (let x = 0; x <= state.gridWidth; x++) {
                        ctx.beginPath();
                        ctx.moveTo(x * baseCellSize, 0);
                        ctx.lineTo(x * baseCellSize, state.gridHeight * baseCellSize);
                        ctx.stroke();
                    }
                    // Draw horizontal lines
                    for (let y = 0; y <= state.gridHeight; y++) {
                        ctx.beginPath();
                        ctx.moveTo(0, y * baseCellSize);
                        ctx.lineTo(state.gridWidth * baseCellSize, y * baseCellSize);
                        ctx.stroke();
                    }
                }

                ctx.restore(); // Restore the canvas context to its state before scaling
            }

            // --- Simulation Loop ---
            // The main animation loop, controlled by requestAnimationFrame.
            function gameLoop(timestamp) {
                if (!state.simulationRunning) {
                    return; // Stop the loop if simulation is paused
                }

                // FPS calculation
                if (state.lastFrameTime === 0) state.lastFrameTime = timestamp;
                const deltaTime = timestamp - state.lastFrameTime;
                state.lastFrameTime = timestamp;

                state.frameCounter++;
                // Update FPS display roughly every 100ms or every 60 frames
                if (deltaTime > 100 || state.frameCounter % 60 === 0) {
                    state.fps = Math.round(1000 / deltaTime);
                    updateStatusBar();
                }

                // Skip frames to control simulation speed: compute next generation only after `framesToSkip` frames
                if (state.frameCounter > state.framesToSkip) {
                    state.frameCounter = 0; // Reset frame counter
                    // Request computation from the Web Worker, transferring the current grid buffer
                    worker.postMessage({
                        type: 'compute',
                        payload: {
                            currentGrid: state.currentGrid,
                            birthRules: Array.from(state.rules.birth), // Convert Set to Array for transfer
                            survivalRules: Array.from(state.rules.survival),
                            neighborhoodType: state.rules.neighborhood
                        }
                    }, [state.currentGrid.buffer]); // Transfer the buffer to worker for efficiency
                    // The worker's `onmessage` handler will receive the computed grid and call `requestAnimationFrame` for the next step.
                } else {
                    // If not computing this frame, just request the next animation frame to keep the UI responsive
                    state.animationFrameId = requestAnimationFrame(gameLoop);
                }
            }

            // --- Simulation Controls ---
            function startSimulation() {
                if (!state.simulationRunning) {
                    setState({ simulationRunning: true });
                    state.animationFrameId = requestAnimationFrame(gameLoop); // Start the animation loop
                }
            }

            function pauseSimulation() {
                if (state.simulationRunning) {
                    setState({ simulationRunning: false });
                    if (state.animationFrameId) {
                        cancelAnimationFrame(state.animationFrameId); // Stop the animation loop
                        state.animationFrameId = null;
                    }
                }
            }

            function stepSimulation() {
                if (!state.simulationRunning) { // Allow stepping only when simulation is paused
                    // Directly request computation from the Web Worker for a single step
                    worker.postMessage({
                        type: 'compute',
                        payload: {
                            currentGrid: state.currentGrid,
                            birthRules: Array.from(state.rules.birth),
                            survivalRules: Array.from(state.rules.survival),
                            neighborhoodType: state.rules.neighborhood
                        }
                    }, [state.currentGrid.buffer]);
                }
            }

            function resetSimulation() {
                pauseSimulation(); // Pause if running
                initializeGrid(false); // Clear the grid
                setState({ generation: 0, liveCells: 0, fps: 0 }); // Reset metrics
            }

            // --- Rule Engine ---
            // Parses a rule string (e.g., "B3/S23") into birth and survival rule sets.
            function parseRuleString(ruleString) {
                const match = ruleString.match(/B(\d*)\/S(\d*)/i);
                if (!match) return null; // Return null if the string format is invalid

                const birthStr = match[1];
                const survivalStr = match[2];

                // Convert digit strings to sets of numbers, filtering for valid neighbor counts (0-8)
                const birth = new Set(birthStr.split('').map(Number).filter(n => n >= 0 && n <= 8));
                const survival = new Set(survivalStr.split('').map(Number).filter(n => n >= 0 && n <= 8));

                return { birth, survival };
            }

            // Generates a rule string (e.g., "B3/S23") from birth and survival rule sets.
            function generateRuleString(birthSet, survivalSet) {
                // Sort numbers for consistent output
                const sortedBirth = Array.from(birthSet).sort((a, b) => a - b).join('');
                const sortedSurvival = Array.from(survivalSet).sort((a, b) => a - b).join('');
                return `B${sortedBirth}/S${sortedSurvival}`;
            }

            // Updates the UI elements (text input, radio buttons, checkboxes) to reflect current rule state.
            function updateRuleUIFromState() {
                ruleInput.value = generateRuleString(state.rules.birth, state.rules.survival);

                neighborhoodTypeRadios.forEach(radio => {
                    radio.checked = radio.value === state.rules.neighborhood;
                });

                // Update visual rule builder checkboxes
                for (let i = 0; i <= 8; i++) {
                    const birthCheckbox = document.getElementById(`birth-${i}`);
                    if (birthCheckbox) birthCheckbox.checked = state.rules.birth.has(i);

                    const survivalCheckbox = document.getElementById(`survival-${i}`);
                    if (survivalCheckbox) survivalCheckbox.checked = state.rules.survival.has(i);
                }
            }

            // Dynamically creates checkboxes for the visual rule builder (0-8 neighbors).
            function createRuleCheckboxes(container, type) {
                for (let i = 0; i <= 8; i++) {
                    const label = document.createElement('label');
                    label.className = 'checkbox-label'; // Apply Tailwind classes
                    label.innerHTML = `
                        <input type="checkbox" id="${type}-${i}" value="${i}" class="form-checkbox" aria-label="${type} condition for ${i} neighbors">
                        <span class="ml-2">${i}</span>
                    `;
                    // Add event listener to update state when checkbox changes
                    label.querySelector('input').addEventListener('change', (e) => {
                        const num = Number(e.target.value);
                        const newRules = { ...state.rules }; // Create a shallow copy of rules object
                        // Ensure the birth/survival sets are also new Set instances to trigger React-like updates if used
                        newRules[type] = new Set(state.rules[type]); // Create a new Set from the old one
                        if (e.target.checked) {
                            newRules[type].add(num);
                        } else {
                            newRules[type].delete(num);
                        }
                        setState({ rules: newRules }); // Update the application state
                    });
                    container.appendChild(label);
                }
            }

            // --- Pattern Presets ---
            // Predefined common cellular automata patterns.
            const presets = {
                glider: [
                    [1, 0, 0],
                    [0, 1, 1],
                    [1, 1, 0]
                ],
                lightWeightSpaceship: [
                    [0, 1, 1, 0, 0],
                    [1, 1, 1, 1, 0],
                    [1, 1, 0, 1, 1],
                    [0, 0, 1, 1, 0]
                ],
                gosperGliderGun: [
                    // Represented as a sparse array of [x,y] coordinates for easier definition
                    [0,4],[1,4],[0,5],[1,5],
                    [10,4],[11,4],[10,5],[11,5],[10,6],[12,3],[12,7],[13,2],[13,8],[14,2],[14,8],[15,5],[16,3],[16,7],[17,4],[17,5],[17,6],
                    [20,2],[21,2],[20,3],[21,3],[20,4],[22,1],[22,5],[24,0],[24,1],[24,5],[24,6],
                    [34,2],[35,2],[34,3],[35,3]
                ],
                pulsar: [
                    [2,0],[3,0],[4,0],[8,0],[9,0],[10,0],
                    [0,2],[5,2],[7,2],[12,2],
                    [0,3],[5,3],[7,3],[12,3],
                    [0,4],[5,4],[7,4],[12,4],
                    [2,5],[3,5],[4,5],[8,5],[9,5],[10,5],

                    [2,7],[3,7],[4,7],[8,7],[9,7],[10,7],
                    [0,8],[5,8],[7,8],[12,8],
                    [0,9],[5,9],[7,9],[12,9],
                    [0,10],[5,10],[7,10],[12,10],
                    [2,12],[3,12],[4,12],[8,12],[9,12],[10,12]
                ],
                tenCellRow: [
                    [0,0],[1,0],[2,0],[3,0],[4,0],[5,0],[6,0],[7,0],[8,0],[9,0]
                ]
            };

            // Loads a selected preset pattern onto the grid.
            function loadPreset(presetName) {
                const pattern = presets[presetName];
                if (!pattern) return;

                pauseSimulation(); // Pause simulation before loading new pattern
                initializeGrid(false); // Clear the current grid

                let offsetX = 0;
                let offsetY = 0;

                // Determine pattern type: 2D array (e.g., Glider) or array of [x,y] coordinates (e.g., Gosper Glider Gun)
                if (Array.isArray(pattern[0])) { // It's a 2D array representation
                    let maxX = 0, maxY = pattern.length;
                    pattern.forEach(row => {
                        if (row.length > maxX) maxX = row.length;
                    });

                    // Calculate offset to center the pattern on the grid
                    offsetX = Math.floor((state.gridWidth - maxX) / 2);
                    offsetY = Math.floor((state.gridHeight - maxY) / 2);

                    pattern.forEach((row, y) => {
                        row.forEach((cell, x) => {
                            if (cell === 1) {
                                setCell(offsetX + x, offsetY + y, 1);
                            }
                        });
                    });
                } else { // It's an array of [x,y] coordinates
                    // Find min/max coordinates to calculate pattern dimensions and center it
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    pattern.forEach(([x, y]) => {
                        if (x < minX) minX = x;
                        if (y < minY) minY = y;
                        if (x > maxX) maxX = x;
                        if (y > maxY) maxY = y;
                    });

                    const patternWidth = maxX - minX + 1;
                    const patternHeight = maxY - minY + 1;

                    offsetX = Math.floor((state.gridWidth - patternWidth) / 2) - minX;
                    offsetY = Math.floor((state.gridHeight - patternHeight) / 2) - minY;

                    pattern.forEach(([x, y]) => {
                        setCell(offsetX + x, offsetY + y, 1);
                    });
                }
                // Update live cell count and redraw after placing the pattern
                state.liveCells = Array.from(state.currentGrid).filter(c => c === 1).length;
                updateStatusBar();
                drawGrid();
            }

            // --- Persistence (Local Storage & URL Hash) ---
            // Saves the current grid pattern and rules to local storage.
            function saveCurrentPattern() {
                const patternName = prompt("Enter a name for your pattern:");
                if (!patternName) return; // User cancelled

                // Check if a pattern with this name already exists
                if (state.savedPatterns[patternName]) {
                    if (!confirm(`A pattern named "${patternName}" already exists. Overwrite?`)) {
                        return; // User chose not to overwrite
                    }
                }

                const patternData = {
                    grid: Array.from(state.currentGrid), // Convert Uint8Array to regular Array for JSON serialization
                    rules: {
                        birth: Array.from(state.rules.birth), // Convert Set to Array
                        survival: Array.from(state.rules.survival), // Convert Set to Array
                        neighborhood: state.rules.neighborhood
                    }
                };

                state.savedPatterns[patternName] = patternData;
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(state.savedPatterns)); // Save to local storage
                alert(`Pattern "${patternName}" saved!`);
                loadSavedPatternsToModal(); // Refresh the list in the modal
            }

            // Loads saved patterns from local storage and displays them in a modal.
            function loadSavedPatterns() {
                const saved = localStorage.getItem(LOCAL_STORAGE_KEY);
                if (saved) {
                    state.savedPatterns = JSON.parse(saved);
                } else {
                    state.savedPatterns = {}; // Initialize empty if no saved patterns found
                }
                loadSavedPatternsToModal(); // Populate the modal with saved patterns
                loadPatternModal.classList.remove('hidden'); // Show the modal
            }

            // Populates the modal with buttons to load or delete saved patterns.
            function loadSavedPatternsToModal() {
                modalSavedPatternsList.innerHTML = ''; // Clear existing list
                const patternNames = Object.keys(state.savedPatterns);

                if (patternNames.length === 0) {
                    modalSavedPatternsList.innerHTML = '<p class="text-gray-400">No saved patterns found.</p>';
                    return;
                }

                patternNames.forEach(name => {
                    const div = document.createElement('div');
                    div.className = 'flex justify-between items-center py-1 border-b border-gray-600 last:border-b-0';
                    div.innerHTML = `
                        <span class="text-gray-200">${name}</span>
                        <div>
                            <button class="btn-secondary text-xs px-2 py-1 mr-2 load-btn" data-pattern-name="${name}" aria-label="Load pattern ${name}">Load</button>
                            <button class="btn-secondary text-xs px-2 py-1 delete-btn" data-pattern-name="${name}" aria-label="Delete pattern ${name}">Delete</button>
                        </div>
                    `;
                    modalSavedPatternsList.appendChild(div);
                });

                // Add event listeners for load buttons
                modalSavedPatternsList.querySelectorAll('.load-btn').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const name = e.target.dataset.patternName;
                        const patternData = state.savedPatterns[name];
                        if (patternData) {
                            pauseSimulation();
                            // Create a new Uint8Array from loaded grid data.
                            // Handle potential size mismatches by creating a new grid of current dimensions
                            // and copying what fits.
                            const loadedGrid = new Uint8Array(patternData.grid);
                            let newCurrentGrid = new Uint8Array(state.gridWidth * state.gridHeight);
                            const copyLength = Math.min(loadedGrid.length, newCurrentGrid.length);
                            newCurrentGrid.set(loadedGrid.slice(0, copyLength));

                            setState({
                                currentGrid: newCurrentGrid,
                                rules: {
                                    birth: new Set(patternData.rules.birth),
                                    survival: new Set(patternData.rules.survival),
                                    neighborhood: patternData.rules.neighborhood
                                }
                            });
                            state.liveCells = Array.from(state.currentGrid).filter(c => c === 1).length;
                            state.generation = 0;
                            updateStatusBar();
                            drawGrid();
                            loadPatternModal.classList.add('hidden'); // Hide modal after loading
                            alert(`Pattern "${name}" loaded!`);
                        }
                    });
                });

                // Add event listeners for delete buttons
                modalSavedPatternsList.querySelectorAll('.delete-btn').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const name = e.target.dataset.patternName;
                        if (confirm(`Are you sure you want to delete "${name}"?`)) {
                            delete state.savedPatterns[name]; // Remove from object
                            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(state.savedPatterns)); // Update local storage
                            loadSavedPatternsToModal(); // Refresh the list
                        }
                    });
                });
            }

            // Encodes the current application state into the URL hash for sharing.
            function encodeStateToUrl() {
                // Use a simple Run-Length Encoding (RLE) to compress grid data for shorter URLs.
                let rleGrid = '';
                let count = 0;
                let lastState = -1; // -1 for initial state, 0 for dead, 1 for alive

                for (let i = 0; i < state.currentGrid.length; i++) {
                    const currentState = state.currentGrid[i];
                    if (currentState !== lastState) {
                        if (count > 0) {
                            rleGrid += `${count}${lastState}`; // Append count and state
                        }
                        lastState = currentState;
                        count = 1;
                    } else {
                        count++;
                    }
                }
                if (count > 0) {
                    rleGrid += `${count}${lastState}`; // Append final segment
                }
                const encodedGrid = btoa(rleGrid); // Base64 encode the RLE string

                const ruleStr = generateRuleString(state.rules.birth, state.rules.survival);
                const neighborhood = state.rules.neighborhood;
                const aliveColor = state.cellColors.alive.replace('#', ''); // Remove '#' for simpler URL
                const deadColor = state.cellColors.dead.replace('#', '');
                const gridLines = state.gridLinesVisible ? 1 : 0;
                const zoom = state.zoomLevel.toFixed(1);

                // Use URLSearchParams to build the query string for the hash
                const params = new URLSearchParams();
                params.append('g', encodedGrid);
                params.append('r', ruleStr);
                params.append('n', neighborhood);
                params.append('ac', aliveColor);
                params.append('dc', deadColor);
                params.append('gl', gridLines);
                params.append('z', zoom);

                // Construct the full URL with the hash
                const url = window.location.origin + window.location.pathname + '#' + params.toString();
                // Copy the URL to the clipboard
                navigator.clipboard.writeText(url).then(() => {
                    alert('Current state URL copied to clipboard! You can share this link.');
                }).catch(err => {
                    console.error('Failed to copy URL:', err);
                    alert('Failed to copy URL to clipboard. Please copy from address bar manually: ' + url);
                });
            }

            // Decodes application state from the URL hash and applies it.
            function decodeStateFromUrl() {
                const hash = window.location.hash.substring(1); // Get hash without leading '#'
                if (!hash) return false; // No hash found

                try {
                    const params = new URLSearchParams(hash);
                    const encodedGrid = params.get('g');
                    const ruleStr = params.get('r');
                    const neighborhood = params.get('n');
                    const aliveColor = params.get('ac');
                    const deadColor = params.get('dc');
                    const gridLines = params.get('gl');
                    const zoom = params.get('z');

                    if (encodedGrid) {
                        const decodedRleGrid = atob(encodedGrid); // Base64 decode
                        let decodedGridArray = new Uint8Array(state.gridWidth * state.gridHeight);
                        let currentIdx = 0;
                        let num = '';
                        // Decode RLE string back to Uint8Array
                        for (let i = 0; i < decodedRleGrid.length; i++) {
                            const char = decodedRleGrid[i];
                            if (char === '0' || char === '1') { // If it's a state character
                                const count = parseInt(num);
                                const stateValue = parseInt(char);
                                for (let j = 0; j < count && currentIdx < decodedGridArray.length; j++) {
                                    decodedGridArray[currentIdx++] = stateValue;
                                }
                                num = ''; // Reset number buffer
                            } else { // If it's a number character
                                num += char;
                            }
                        }
                        setState({ currentGrid: decodedGridArray });
                    }

                    if (ruleStr) {
                        const parsedRules = parseRuleString(ruleStr);
                        if (parsedRules) {
                            setState({
                                rules: {
                                    ...state.rules,
                                    birth: parsedRules.birth,
                                    survival: parsedRules.survival
                                }
                            });
                        }
                    }

                    if (neighborhood && (neighborhood === 'moore' || neighborhood === 'vonNeumann')) {
                        setState({ rules: { ...state.rules, neighborhood: neighborhood } });
                    }

                    if (aliveColor) setState({ cellColors: { ...state.cellColors, alive: `#${aliveColor}` } });
                    if (deadColor) setState({ cellColors: { ...state.cellColors, dead: `#${deadColor}` } });
                    if (gridLines !== null) setState({ gridLinesVisible: gridLines === '1' });
                    if (zoom) setState({ zoomLevel: parseFloat(zoom) });

                    // Recalculate live cells and reset generation counter for loaded state
                    state.liveCells = Array.from(state.currentGrid).filter(c => c === 1).length;
                    state.generation = 0;
                    updateStatusBar();
                    drawGrid(); // Redraw the canvas with loaded state
                    return true; // State was successfully decoded
                } catch (e) {
                    console.error("Failed to decode state from URL:", e);
                    return false; // Decoding failed
                }
            }


            // --- Status Bar Update ---
            // Updates the text content of the status bar elements.
            function updateStatusBar() {
                generationCountSpan.textContent = state.generation;
                liveCellCountSpan.textContent = state.liveCells;
                fpsCountSpan.textContent = state.fps.toFixed(0); // Display FPS as integer
            }

            // --- Event Listeners Setup ---
            // Attaches all necessary event listeners to UI elements.
            function setupEventListeners() {
                // Simulation Controls
                playPauseBtn.addEventListener('click', () => {
                    if (state.simulationRunning) {
                        pauseSimulation();
                    } else {
                        startSimulation();
                    }
                });
                stepBtn.addEventListener('click', stepSimulation);
                resetBtn.addEventListener('click', resetSimulation);
                speedSlider.addEventListener('input', (e) => {
                    setState({ simulationSpeed: Number(e.target.value) });
                });

                // Drawing Tools
                brushSizeSlider.addEventListener('input', (e) => {
                    setState({ brushSize: Number(e.target.value) });
                });
                fillGridBtn.addEventListener('click', () => initializeGrid(true));
                clearGridBtn.addEventListener('click', () => initializeGrid(false));

                // Canvas Drawing Interaction
                let lastGridX = -1, lastGridY = -1; // Track last drawn cell to optimize mousemove
                canvas.addEventListener('mousedown', (e) => {
                    if (e.button === 0 || e.button === 2) { // Allow left click (draw) or right click (erase)
                        state.isDrawing = true;
                        state.drawMode = (e.button === 0) ? 1 : 0; // 1 for alive, 0 for dead (erase)
                        const rect = canvas.getBoundingClientRect(); // Get canvas position and size
                        // Calculate mouse position relative to canvas, considering CSS scaling
                        const canvasX = e.clientX - rect.left;
                        const canvasY = e.clientY - rect.top;
                        drawBrush(canvasX, canvasY, state.drawMode);
                        // Store the grid coordinates of the cell under the mouse
                        lastGridX = Math.floor(canvasX / (BASE_CELL_SIZE_PX * state.zoomLevel));
                        lastGridY = Math.floor(canvasY / (BASE_CELL_SIZE_PX * state.zoomLevel));
                        e.preventDefault(); // Prevent default right-click context menu
                    }
                });
                canvas.addEventListener('mousemove', (e) => {
                    if (!state.isDrawing) return; // Only draw if mouse button is held down
                    const rect = canvas.getBoundingClientRect();
                    const canvasX = e.clientX - rect.left;
                    const canvasY = e.clientY - rect.top;
                    const currentGridX = Math.floor(canvasX / (BASE_CELL_SIZE_PX * state.zoomLevel));
                    const currentGridY = Math.floor(canvasY / (BASE_CELL_SIZE_PX * state.zoomLevel));

                    // Only draw if the brush has moved to a new cell to avoid redundant redraws
                    if (currentGridX !== lastGridX || currentGridY !== lastGridY) {
                        drawBrush(canvasX, canvasY, state.drawMode);
                        lastGridX = currentGridX;
                        lastGridY = currentGridY;
                    }
                });
                canvas.addEventListener('mouseup', () => {
                    state.isDrawing = false; // Stop drawing when mouse button is released
                    // Update live cell count after drawing is finished
                    state.liveCells = Array.from(state.currentGrid).filter(c => c === 1).length;
                    updateStatusBar();
                });
                canvas.addEventListener('contextmenu', (e) => e.preventDefault()); // Prevent default right-click menu

                // Rule Editor
                ruleInput.addEventListener('input', (e) => {
                    const parsed = parseRuleString(e.target.value);
                    if (parsed) {
                        setState({ rules: { ...state.rules, birth: parsed.birth, survival: parsed.survival } });
                    }
                });
                neighborhoodTypeRadios.forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        setState({ rules: { ...state.rules, neighborhood: e.target.value } });
                    });
                });

                // Visual Settings
                aliveColorPicker.addEventListener('input', (e) => {
                    setState({ cellColors: { ...state.cellColors, alive: e.target.value } });
                });
                deadColorPicker.addEventListener('input', (e) => {
                    setState({ cellColors: { ...state.cellColors, dead: e.target.value } });
                });
                gridLinesToggle.addEventListener('change', (e) => {
                    setState({ gridLinesVisible: e.target.checked });
                });
                zoomSlider.addEventListener('input', (e) => {
                    setState({ zoomLevel: Number(e.target.value) });
                });
                shareLinkBtn.addEventListener('click', encodeStateToUrl); // Share button

                // Pattern Presets & Persistence
                presetSelect.addEventListener('change', (e) => {
                    if (e.target.value) {
                        loadPreset(e.target.value);
                        e.target.value = ''; // Reset select to prompt user for next selection
                    }
                });
                savePatternBtn.addEventListener('click', saveCurrentPattern);
                loadPatternBtn.addEventListener('click', loadSavedPatterns);
                closeModalBtn.addEventListener('click', () => loadPatternModal.classList.add('hidden'));
            }

            // --- Initialization Function ---
            // This function runs when the DOM is fully loaded.
            function init() {
                setupCanvasDimensions(); // Set the canvas's internal pixel dimensions
                setupWorker(); // Initialize the Web Worker for computation
                initializeGrid(false); // Start with an empty grid
                setupEventListeners(); // Attach all UI event handlers
                // Dynamically create checkboxes for visual rule builder
                createRuleCheckboxes(birthConditionsDiv, 'birth');
                createRuleCheckboxes(survivalConditionsDiv, 'survival');

                // Attempt to decode state from URL hash first (for shared links)
                if (!decodeStateFromUrl()) {
                    // If no state was loaded from URL, set default UI values
                    ruleInput.value = generateRuleString(state.rules.birth, state.rules.survival);
                    neighborhoodTypeRadios.forEach(radio => {
                        if (radio.value === state.rules.neighborhood) radio.checked = true;
                    });
                    aliveColorPicker.value = state.cellColors.alive;
                    deadColorPicker.value = state.cellColors.dead;
                    gridLinesToggle.checked = state.gridLinesVisible;
                    speedSlider.value = state.simulationSpeed;
                    brushSizeSlider.value = state.brushSize;
                    zoomSlider.value = state.zoomLevel;
                    updateRuleUIFromState(); // Sync visual rule builder checkboxes
                    // Trigger initial updates for sliders to display their values
                    setState({
                        simulationSpeed: state.simulationSpeed,
                        brushSize: state.brushSize,
                        zoomLevel: state.zoomLevel
                    });
                }
                drawGrid(); // Perform an initial draw of the grid
            }

            // Ensure `init` runs only after the entire DOM is loaded
            document.addEventListener('DOMContentLoaded', init);
        })(); // End of IIFE
    </script>

    <div style="position:fixed;bottom:10px;right:10px;background:rgba(0,0,0,0.7);color:white;padding:5px 10px;border-radius:5px;font-family:sans-serif;font-size:12px">
        Created by Dakota Rain Lock, powered by Holy Grail. A Dakota Rain Lock Invention.
    </div>
    
</body>
</html>
